= Midterm Review

== Midterm Structure
* Coding questions:
	** Difference between what happens in a mutex with a wait and semaphore
	** Producer-Consumer problem solutions vs Critical-Section problem
* Short answer questions:
	** Explain bakery algorithm
	** What are solution to critical-section problem
* Bonus questions: (never count against you but can only help you)
	** There are 8 questions you only need to answer 6.
	** Possible to get more than 100 on test.
	** Number of questions: 8 pages (Hour and a half)

== Midterm Review Material

=== Chapter 1
* History
	** *Resident monitor:* Introducted in 1953 at IBM. Earliest appearance of what would become an Operating System. Monitor decided what to do next which resulted in continuous operation and more automation.
* *Types of Operating Systems*
	** Mainframe or minicomputer systems - Apache, Windows Server, etc.
	** Workstations connected to servers - Linux, MacOS, Windows
	** Mobile computers - iOS, Android
* Multiprogramming
	** Goal is to keep CPU as busy as possible and increase throughput.
	** Process: Job runs on CPU until it has to wait (usually I/O), CPU runs another job until that job needs to wait, CPU returns to previous job it if it ready to run again.
	** Requires: Memory management, CPU scheduling, and Resource Allocation.

=== Chapter 3
* *I/O-bound*
	** spends more time doing I/O than computations, many short CPU bursts.
* *CPU-bound*
	** spends more time doing computations; few very long CPU bursts
* Multiprocessors
	** Tightly coupled: Often there is a dependency. Super computers
	** Loosely coupled: All processors opperate the same way.
* Synchronous / Asynchronous: Synchronous opperations need to wait unitl something is done or complete for it to proceed (I/O), asynchronous operations do not need to wait for one another.
* Programmed I/O: Synchronous handeling of I/O where the CPU waits for I/O to complete.
* Interrupts and interrupt handling: Interrupts are indentified by a number. There is an interrupt vector in memory that tells the CPU the LOCATION of code where instructions are stored to handle that specfic interrupt.
* Interrupt-driven I/O: Asynchronous handelign of I/O where the CPU requests I/O, goes off an does other tasks, and then I/O interrupts the CPU later.
* System calls, exceptions, traps:
	** System Calls: Software level interrupts.  User level requests kernel to do I/O.
	** Exceptions: Software generated signel to program or OS that something significat has happened.
* DMA: Direct Memory Access - CPU does not need to read/write to memory a DMA controller can do it instead so I/O does not need to bother the CPU for memory access.
* Messages and message driven systems: An alternative to interrupts for communication. Not as quick, but can handle more data.
* Hardware protection of systems
	** I/O: Dual mode operation: There are user and kernel level instructions. I/O instructions can only be done by kernel level.  So user makes system call to kernal to do I/O and the kernal determines if the instruction is appropriate.
	** Memory: Base/limit registers: Stores the address of the base and limit for the memory space that the user level instruction has access too.
	** CPU: Timer: Amount of time a process is allowed to use the processor before timeout.
* Processes and threads
	** Similarities and differences:
	** When to use
	** User-level and kernel-level threads
	** Thread mapping: 1:1, 1:N, N:N
	** *Interprocess communication*: Messages, message queue, blocking sends, non-blocking recieves.
	** Sockets
	** Remote Proccedure Calls (RPCs), Remote Method Invocations (RMIs), Marshalling, etc.: Process on SysA wants a Process on SysB to do work for it.  SysB will give SysA a port.  SysA will send request to port, to invoke a Method/Proccedure. Parameters are Marshalled into a format known by SysB.
* CPU scheduling:
	** CPU * I/O burst cycle
	** Scheduling algorithm criteria
	** Scheduling (and other) queues
	** Schedulers, dispatcher, PCBs, etc.
	** Context switches
	** Process states
	** Process (and thread) creation / termination
* *Scheduling algorithms*
	** Optimal
	** FCFS
	** SJF
	** SRTF
	** Priority
	** RR
	** MLQ
	** MLFQ
* Scheduling terminology / criteria / evaluation
	** Preemptive / non-preemptive
	** Average Wait Time, Average Turnaround Time, Gantt charts
	** Time quantum
	** Time quantum, context switch
* What is concurrency and why is it important?
	** Atomicity
	** Starvation / deadlock
* Producer / consumer problem
	** Parallelism
	** Bounded / unbounded buffers
	** Various solutions
	** Why there are concurrency problems
* Critical section problem
	** Various parts: Entry, CS, Exit
		*** Critical Section:
	** Requirements for solutions
		*** Mutual exclusion
		*** Progress
		*** Bounded wait
	** Flaws with attempted solutions: Mutual Exclusion or Starvation
	** Bakery Algorithm
* Semaphores
	** Mutexes
	** Binary / Counting
	** Busy waits / spinlocks
	** Test-and-Set / Swap
	** signal() and wait()
* Classical concurrency problems
	** Readers - Writers Problem
		*** 1st / 2nd : solutions / problems
	** Dining Philosophers Problem
* Critical regions
* Monitors: Object that encapsolates the shared data and hides the synchronization from the person that implements it.


